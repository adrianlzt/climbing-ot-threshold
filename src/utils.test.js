import { findInflectionPoint } from './utils';

describe('findInflectionPoint', () => {
  it('should return an empty array if less than 4 pull means are provided', () => {
    const pullMeans = [
      { middleTime: 1, meanWeight: 10, startTime: 0, endTime: 2 },
      { middleTime: 3, meanWeight: 12, startTime: 2, endTime: 4 },
      { middleTime: 5, meanWeight: 14, startTime: 4, endTime: 6 },
    ];
    const result = findInflectionPoint(pullMeans);
    expect(result).toEqual([]);
  });

  it('should calculate the inflection point correctly for a simple case', () => {
    // Data generated by the the exampleData.generateArray.
    const pullMeans = [
      { meanWeight: 38.2, startTime: 0, endTime: 9, middleTime: 4.5 },
      { meanWeight: 34.6, startTime: 10, endTime: 19, middleTime: 14.5 },
      { meanWeight: 30.999999999999996, startTime: 20, endTime: 29, middleTime: 24.5, },
      { meanWeight: 27.399999999999995, startTime: 30, endTime: 39, middleTime: 34.5, },
      { meanWeight: 23.799999999999997, startTime: 40, endTime: 49, middleTime: 44.5, },
      { meanWeight: 21.75, startTime: 50, endTime: 59, middleTime: 54.5, },
      { meanWeight: 21.25, startTime: 60, endTime: 69, middleTime: 64.5, },
      { meanWeight: 20.75, startTime: 70, endTime: 79, middleTime: 74.5, },
      { meanWeight: 20.25, startTime: 80, endTime: 89, middleTime: 84.5, }
    ];

    const result = findInflectionPoint(pullMeans);

    expect(result.length).toBe(6);
    expect(result[0].i).toBe(5);
    expect(result[0].otWeight).toBeCloseTo(22.0, 1);
    expect(result[0].otTime).toBeCloseTo(49.5, 1);
    expect(result[0].r2Sum).toBe(2);
  });

  it('should discard results where the former phase has a larger slope', () => {
    const pullMeans = [
      { middleTime: 1, meanWeight: 6, startTime: 0, endTime: 2 },
      { middleTime: 3, meanWeight: 8, startTime: 2, endTime: 4 },
      { middleTime: 5, meanWeight: 12, startTime: 4, endTime: 6 },
      { middleTime: 7, meanWeight: 10, startTime: 6, endTime: 8 },
    ];
    const result = findInflectionPoint(pullMeans);
    // Expect no results since the first slope should be greater than the second
    expect(result).toEqual([]);
  });

  it('should discard results where the cross point is out of range', () => {
    const pullMeans = [
      { middleTime: 1, meanWeight: 10, startTime: 0, endTime: 2 },
      { middleTime: 3, meanWeight: 11, startTime: 2, endTime: 4 },
      { middleTime: 9, meanWeight: 5, startTime: 8, endTime: 10 },
      { middleTime: 11, meanWeight: 4, startTime: 10, endTime: 12 },
    ];
    const result = findInflectionPoint(pullMeans);
    // Expect no results since the cross point will be outside the range
    expect(result).toEqual([]);
  });

  it('should return multiple results and sort by r2Sum in descending order', () => {
    const pullMeans = [
      { meanWeight: 38.2, startTime: 0, endTime: 9, middleTime: 4.5 },
      { meanWeight: 34.6, startTime: 10, endTime: 19, middleTime: 14.5 },
      { meanWeight: 30.999999999999996, startTime: 20, endTime: 29, middleTime: 24.5, },
      { meanWeight: 27.399999999999995, startTime: 30, endTime: 39, middleTime: 34.5, },
      { meanWeight: 23.799999999999997, startTime: 40, endTime: 49, middleTime: 44.5, },
      { meanWeight: 21.75, startTime: 50, endTime: 59, middleTime: 54.5, },
      { meanWeight: 21.25, startTime: 60, endTime: 69, middleTime: 64.5, },
      { meanWeight: 20.75, startTime: 70, endTime: 79, middleTime: 74.5, },
      { meanWeight: 20.25, startTime: 80, endTime: 89, middleTime: 84.5, }
    ];

    const result = findInflectionPoint(pullMeans);
    expect(result.length).toBeGreaterThan(1); // Expect at least two possible inflection points

    // Check if the results are sorted by r2Sum in descending order
    for (let i = 0; i < result.length - 1; i++) {
      expect(result[i].r2Sum).toBeGreaterThanOrEqual(result[i + 1].r2Sum);
    }
  });
});
